(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[7040,7893],{95644:(i,n,t)=>{"use strict";t.d(n,{N:()=>g});const o="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",e={lightSources:{}};function l({color:i=[0,0,0],intensity:n=1}={}){return i.map((i=>i*n/255))}const r={};const g={name:"gouraud-lighting",dependencies:[{name:"lights",vs:o,fs:o,getUniforms:function i(n=e){if("lightSources"in n){const{ambientLight:i,pointLights:t,directionalLights:o}=n.lightSources||{};return i||t&&t.length>0||o&&o.length>0?Object.assign({},function({ambientLight:i,pointLights:n=[],directionalLights:t=[]}){const o={};return o["lighting_uAmbientLight.color"]=i?l(i):[0,0,0],n.forEach(((i,n)=>{o["lighting_uPointLight[".concat(n,"].color")]=l(i),o["lighting_uPointLight[".concat(n,"].position")]=i.position,o["lighting_uPointLight[".concat(n,"].attenuation")]=i.attenuation||[1,0,0]})),o.lighting_uPointLightCount=n.length,t.forEach(((i,n)=>{o["lighting_uDirectionalLight[".concat(n,"].color")]=l(i),o["lighting_uDirectionalLight[".concat(n,"].direction")]=i.direction})),o.lighting_uDirectionalLightCount=t.length,o}({ambientLight:i,pointLights:t,directionalLights:o}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in n){const t={pointLights:[],directionalLights:[]};for(const i of n.lights||[])switch(i.type){case"ambient":t.ambientLight=i;break;case"directional":t.directionalLights.push(i);break;case"point":t.pointLights.push(i)}return i({lightSources:t})}return{}},defines:{MAX_LIGHTS:3}}],vs:"\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",defines:{LIGHTING_VERTEX:1},getUniforms:function(i=r){if(!("material"in i))return{};const{material:n}=i;return n?function(i){const{ambient:n=.35,diffuse:t=.6,shininess:o=32,specularColor:e=[30,30,30]}=i;return{lighting_uAmbient:n,lighting_uDiffuse:t,lighting_uShininess:o,lighting_uSpecularColor:e.map((i=>i/255))}}(n):{lighting_uEnabled:!1}}}},92540:()=>{},95751:()=>{},75307:()=>{}}]);