"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[4022],{28569:(e,t,i)=>{i.d(t,{Z:()=>g});var n=i(95772),o=i(93844),s=i(51331),a=i(281),r=i(53982);const l=[0,0,0,255],c={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:l},getLineColor:{type:"accessor",value:l},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class g extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool billboard;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:e,oldProps:t,changeFlags:i}){if(super.updateState({props:e,oldProps:t,changeFlags:i}),i.extensionsChanged){var n;const{gl:e}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{viewport:t}=this.context,{radiusUnits:i,radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,stroked:a,filled:r,billboard:l,lineWidthUnits:c,lineWidthScale:g,lineWidthMinPixels:d,lineWidthMaxPixels:u}=this.props,f="pixels"===i?t.metersPerPixel:1,h="pixels"===c?t.metersPerPixel:1;this.state.model.setUniforms(e).setUniforms({stroked:a?1:0,filled:r,billboard:l,radiusScale:n*f,radiusMinPixels:o,radiusMaxPixels:s,lineWidthScale:g*h,lineWidthMinPixels:d,lineWidthMaxPixels:u}).draw()}_getModel(e){return new a.Z(e,{...this.getShaders(),id:this.props.id,geometry:new r.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}g.layerName="ScatterplotLayer",g.defaultProps=c},49296:e=>{e.exports=i,e.exports.default=i;var t=1e20;function i(e,t,i,n,o,s){this.fontSize=e||24,this.buffer=void 0===t?3:t,this.cutoff=n||.25,this.fontFamily=o||"sans-serif",this.fontWeight=s||"normal",this.radius=i||8;var a=this.size=this.fontSize+2*this.buffer,r=a+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=a,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textAlign="left",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(r*r),this.gridInner=new Float64Array(r*r),this.f=new Float64Array(r),this.z=new Float64Array(r+1),this.v=new Uint16Array(r),this.useMetrics=void 0!==this.ctx.measureText("A").actualBoundingBoxLeft,this.middle=Math.round(a/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function n(e,t,i,n,s,a){for(var r=0;r<t;r++)o(e,r,t,i,n,s,a);for(var l=0;l<i;l++)o(e,l*t,1,t,n,s,a)}function o(e,i,n,o,s,a,r){var l,c,g,d;for(a[0]=0,r[0]=-t,r[1]=t,l=0;l<o;l++)s[l]=e[i+l*n];for(l=1,c=0,g=0;l<o;l++){do{d=a[c],g=(s[l]-s[d]+l*l-d*d)/(l-d)/2}while(g<=r[c]&&--c>-1);a[++c]=l,r[c]=g,r[c+1]=t}for(l=0,c=0;l<o;l++){for(;r[c+1]<l;)c++;d=a[c],e[i+l*n]=s[d]+(l-d)*(l-d)}}i.prototype._draw=function(e,i){var o,s,a,r,l,c,g,d,u,f=this.ctx.measureText(e),h=f.width,p=2*this.buffer;i&&this.useMetrics?(l=Math.floor(f.actualBoundingBoxAscent),d=this.buffer+Math.ceil(f.actualBoundingBoxAscent),c=this.buffer,g=this.buffer,o=(s=Math.min(this.size,Math.ceil(f.actualBoundingBoxRight-f.actualBoundingBoxLeft)))+p,a=(r=Math.min(this.size-c,Math.ceil(f.actualBoundingBoxAscent+f.actualBoundingBoxDescent)))+p,this.ctx.textBaseline="alphabetic"):(o=s=this.size,a=r=this.size,l=19*this.fontSize/24,c=g=0,d=this.middle,this.ctx.textBaseline="middle"),s&&r&&(this.ctx.clearRect(g,c,s,r),this.ctx.fillText(e,this.buffer,d),u=this.ctx.getImageData(g,c,s,r));var x=new Uint8ClampedArray(o*a);return function(e,i,n,o,s,a,r){a.fill(t,0,i*n),r.fill(0,0,i*n);for(var l=(i-o)/2,c=0;c<s;c++)for(var g=0;g<o;g++){var d=(c+l)*i+g+l,u=e.data[4*(c*o+g)+3]/255;if(1===u)a[d]=0,r[d]=t;else if(0===u)a[d]=t,r[d]=0;else{var f=Math.max(0,.5-u),h=Math.max(0,u-.5);a[d]=f*f,r[d]=h*h}}}(u,o,a,s,r,this.gridOuter,this.gridInner),n(this.gridOuter,o,a,this.f,this.v,this.z),n(this.gridInner,o,a,this.f,this.v,this.z),function(e,t,i,n,o,s,a){for(var r=0;r<t*i;r++){var l=Math.sqrt(n[r])-Math.sqrt(o[r]);e[r]=Math.round(255-255*(l/s+a))}}(x,o,a,this.gridOuter,this.gridInner,this.radius,this.cutoff),{data:x,metrics:{width:s,height:r,sdfWidth:o,sdfHeight:a,top:l,left:0,advance:h}}},i.prototype.draw=function(e){return this._draw(e,!1).data},i.prototype.drawWithMetrics=function(e){return this._draw(e,!0)}},24022:(e,t,i)=>{i.r(t),i.d(t,{default:()=>we,getLayer:()=>Oe});var n=i(67294),o=i(45697),s=i.n(o),a=i(78918),r=i(80744),l=i(98452),c=i(95772),g=i(93844),d=i(51331),u=i(281),f=i(53982),h=i(95432),p=i(1953),x=i(4912),y=i(98949),m=i(73838),v=i(38550);const _=()=>{},P={10241:9987,10240:9729,10242:33071,10243:33071};function C(e,t,i,n){return i===t.width&&n===t.height?t:(e.canvas.height=n,e.canvas.width=i,e.clearRect(0,0,e.canvas.width,e.canvas.height),e.drawImage(t,0,0,t.width,t.height,0,0,i,n),e.canvas)}function b(e){return e&&(e.id||e.url)}function S(e,t,i){for(let n=0;n<t.length;n++){const{icon:o,xOffset:s}=t[n];e[b(o)]={...o,x:s,y:i}}}class z{constructor(e,{onUpdate:t=_,onError:i=_}){this.gl=e,this.onUpdate=t,this.onError=i,this._loadOptions=null,this._getIcon=null,this._texture=null,this._externalTexture=null,this._mapping={},this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null}finalize(){var e;null===(e=this._texture)||void 0===e||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?b(e):e;return this._mapping[t]||{}}setProps({loadOptions:e,autoPacking:t,iconAtlas:i,iconMapping:n,data:o,getIcon:s}){e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),s&&(this._getIcon=s),n&&(this._mapping=n),i&&this._updateIconAtlas(i),this._autoPacking&&(o||s)&&"undefined"!=typeof document&&(this._canvas=this._canvas||document.createElement("canvas"),this._updateAutoPacking(o))}get isLoaded(){return 0===this._pendingCount}_updateIconAtlas(e){var t;null===(t=this._texture)||void 0===t||t.delete(),this._texture=null,this._externalTexture=e,this.onUpdate()}_updateAutoPacking(e){const t=Object.values(function(e,t,i){if(!e||!t)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,v.jB)(e);for(const e of o){s.index++;const o=t(e,s),a=b(o);if(!o)throw new Error("Icon is missing.");if(!o.url)throw new Error("Icon url is missing.");n[a]||i[a]&&o.url===i[a].url||(n[a]={...o,source:e,sourceIndex:s.index})}return n}(e,this._getIcon,this._mapping)||{});if(t.length>0){const{mapping:e,xOffset:i,yOffset:n,rowHeight:o,canvasHeight:s}=function({icons:e,buffer:t,mapping:i={},xOffset:n=0,yOffset:o=0,rowHeight:s=0,canvasWidth:a}){let r=[];for(let l=0;l<e.length;l++){const c=e[l];if(!i[b(c)]){const{height:e,width:l}=c;n+l+t>a&&(S(i,r,o),n=0,o=s+o+t,s=0,r=[]),r.push({icon:c,xOffset:n}),n=n+l+t,s=Math.max(s,e)}}return r.length>0&&S(i,r,o),{mapping:i,rowHeight:s,xOffset:n,yOffset:o,canvasWidth:a,canvasHeight:(l=s+o+t,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:t,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=i,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new x.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:P})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,i,n){const o=t.width,s=t.height,a=(0,h.h)(t,{width:i,height:n});return(0,p.Lv)(t,a,{targetY:0,width:o,height:s}),t.delete(),a}(this.gl,this._texture,this._canvasWidth,this._canvasHeight)),this.onUpdate(),this._loadIcons(t)}}_loadIcons(e){const t=this._canvas.getContext("2d");for(const i of e)this._pendingCount++,(0,m.z)(i.url,y.S,this._loadOptions).then((e=>{const n=b(i),{x:o,y:s,width:a,height:r}=this._mapping[n],l=C(t,e,a,r);this._texture.setSubImageData({data:l,x:o,y:s,width:a,height:r}),this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const L=[0,0,0,255],M={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:L},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,compare:!1,optional:!0}};class O extends c.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[g.Z,d.Z]})}initializeState(){this.state={iconManager:new z(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})},this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:L},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState({oldProps:e,props:t,changeFlags:i}){super.updateState({props:t,oldProps:e,changeFlags:i});const n=this.getAttributeManager(),{iconAtlas:o,iconMapping:s,data:a,getIcon:r}=t,{iconManager:l}=this.state;l.setProps({loadOptions:t.loadOptions});let c=!1;if(o||this.internalState.isAsyncPropLoading("iconAtlas")?(e.iconAtlas!==t.iconAtlas&&l.setProps({iconAtlas:o,autoPacking:!1}),e.iconMapping!==t.iconMapping&&(l.setProps({iconMapping:s}),c=!0)):l.setProps({autoPacking:!0}),(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getIcon))&&l.setProps({data:a,getIcon:r}),c&&(n.invalidate("instanceOffsets"),n.invalidate("instanceIconFrames"),n.invalidate("instanceColorModes")),i.extensionsChanged){var g;const{gl:e}=this.context;null===(g=this.state.model)||void 0===g||g.delete(),this.state.model=this._getModel(e),n.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(){super.finalizeState(),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:o,billboard:s,alphaCutoff:a}=this.props,{iconManager:r}=this.state,{viewport:l}=this.context,c=r.getTexture();c&&this.state.model.setUniforms(e).setUniforms({iconsTexture:c,iconsTextureDim:[c.width,c.height],sizeScale:t*("pixels"===o?l.metersPerPixel:1),sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:a}).draw()}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new f.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){const{onIconError:t}=this.getCurrentLayer().props;t?t(e):r.Z.error(e.error)()}getInstanceOffset(e){const t=this.state.iconManager.getIconMapping(e);return[t.width/2-t.anchorX||0,t.height/2-t.anchorY||0]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const t=this.state.iconManager.getIconMapping(e);return[t.x||0,t.y||0,t.width||0,t.height||0]}}O.layerName="IconLayer",O.defaultProps=M;var F=i(28569);const I=[];class A extends O{getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(e,{index:t,target:i})=>this.encodePickingColor(t,i)}})}updateState(e){super.updateState(e);const{props:t,oldProps:i}=e;let{outlineColor:n}=t;n!==i.outlineColor&&(n=n.map((e=>e/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!t.sdf&&t.outlineWidth&&r.Z.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(e){const{sdf:t,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state;e.uniforms={...e.uniforms,buffer:.75,outlineBuffer:n?Math.max(i,.75*(1-n)):-1,gamma:i,sdf:Boolean(t),outlineColor:o},super.draw(e)}getInstanceOffset(e){return e?Array.from(e).map((e=>super.getInstanceOffset(e))):I}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).map((e=>super.getInstanceIconFrame(e))):I}}A.layerName="MultiIconLayer",A.defaultProps={getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}};var w=i(49296),T=i.n(w);const k=[];function W(e,t,i,n){let o=0;for(let s=t;s<i;s++){const t=e[s];let i=null;const a=n&&n[t];a&&(i=a.width),o+=i}return o}function E(e,t,i,n,o,s){let a=t,r=0;for(let l=t;l<i;l++){const t=W(e,l,l+1,o);r+t>n&&(a<l&&s.push(l),a=l,r=0),r+=t}return r}function R(e,t,i,n,o=0,s){void 0===s&&(s=e.length);const a=[];return"break-all"===t?E(e,o,s,i,n,a):function(e,t,i,n,o,s){let a=t,r=t,l=t,c=0;for(let g=t;g<i;g++)if(" "===e[g]?l=g+1:" "!==e[g+1]&&g+1!==i||(l=g+1),l>r){let t=W(e,r,l,o);c+t>n&&(a<r&&(s.push(r),a=r,c=0),t>n&&(t=E(e,r,l,n,o,s),a=s[s.length-1])),r=l,c+=t}}(e,o,s,i,n,a),a}function B(e,t,i,n,o,s){let a=0,l=0;for(let s=t;s<i;s++){const t=e[s],i=n[t];i?(l||(l=i.height),o[s]=a+i.width/2,a+=i.width):(r.Z.warn("Missing character: ".concat(t," (").concat(t.codePointAt(0),")"))(),o[s]=a,a+=32)}s[0]=a,s[1]=l}function D(e,t,i,n,o){const s=(e=Array.from(e)).length,a=new Array(s),r=new Array(s),l=new Array(s),c=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,g=[0,0],d=[];let u=0,f=0,h=0;for(let p=0;p<=s;p++){const x=e[p];if("\n"!==x&&p!==s||(h=p),h>f){const s=c?R(e,i,n,o,f,h):k;for(let i=0;i<=s.length;i++){const n=0===i?f:s[i-1],c=i<s.length?s[i]:h;B(e,n,c,o,a,d);for(let e=n;e<c;e++)r[e]=u+d[1]/2,l[e]=d[0];u+=d[1]*t,g[0]=Math.max(g[0],d[0])}f=h}"\n"===x&&(a[f]=0,r[f]=0,l[f]=0,f++)}return g[1]=u,{x:a,y:r,rowWidth:l,size:g}}const j=function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),U="Monaco, monospace",N="normal",Z=new class{constructor(e=5){this.limit=e,this.clear()}clear(){this._cache={},this._order=[]}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(this._deleteCache(e),this._deleteOrder(e))}_deleteCache(e){delete this._cache[e]}_deleteOrder(e){const t=this._order.findIndex((t=>t===e));t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}(3),G=["fontFamily","fontWeight","characterSet","fontSize","sdf","buffer","cutoff","radius"];function H(e,t){for(let i=0;i<e.length;i++)t.data[4*i+3]=e[i]}function K(e,t,i,n){e.font="".concat(n," ").concat(i,"px ").concat(t),e.fillStyle="#000",e.textBaseline="baseline",e.textAlign="left"}class V{constructor(){this.props={fontFamily:U,fontWeight:N,characterSet:j,fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12},this._key=null,this._atlas=null}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){return 1.2}setProps(e={}){G.forEach((t=>{t in e&&(this.props[t]=e[t])}));const t=this._key;this._key=this._getKey();const i=function(e,t){const i=Z.get(e);if(!i)return t;const n=[],o=i.mapping;let s=Object.keys(o);s=new Set(s);let a=t;return a instanceof Array&&(a=new Set(a)),a.forEach((e=>{s.has(e)||n.push(e)})),n}(this._key,this.props.characterSet),n=Z.get(this._key);if(n&&0===i.length)return void(this._key!==t&&(this._atlas=n));const o=this._generateFontAtlas(this._key,i,n);this._atlas=o,Z.set(this._key,o)}_generateFontAtlas(e,t,i){const{fontFamily:n,fontWeight:o,fontSize:s,buffer:a,sdf:r,radius:l,cutoff:c}=this.props;let g=i&&i.data;g||(g=document.createElement("canvas"),g.width=1024);const d=g.getContext("2d");K(d,n,s,o);const{mapping:u,canvasHeight:f,xOffset:h,yOffset:p}=function({characterSet:e,getFontWidth:t,fontHeight:i,buffer:n,maxCanvasWidth:o,mapping:s={},xOffset:a=0,yOffset:r=0}){let l=0,c=a,g=0;for(const a of e)if(!s[a]){const e=t(a,g++);c+e+2*n>o&&(c=0,l++),s[a]={x:c+n,y:r+l*(i+2*n)+n,width:e,height:i},c+=e+2*n}const d=i+2*n;return{mapping:s,xOffset:c,yOffset:r+l*d,canvasHeight:(u=r+(l+1)*d,Math.pow(2,Math.ceil(Math.log2(u))))};var u}({getFontWidth:e=>d.measureText(e).width,fontHeight:1.2*s,buffer:a,characterSet:t,maxCanvasWidth:1024,...i&&{mapping:i.mapping,xOffset:i.xOffset,yOffset:i.yOffset}});if(g.height!==f){const e=d.getImageData(0,0,g.width,g.height);g.height=f,d.putImageData(e,0,0)}if(K(d,n,s,o),r){const e=new(T())(s,a,l,c,n,o),i=d.getImageData(0,0,e.size,e.size);for(const n of t)H(e.draw(n),i),d.putImageData(i,u[n].x-a,u[n].y+a)}else for(const e of t)d.fillText(e,u[e].x,u[e].y+.9*s);return{xOffset:h,yOffset:p,mapping:u,data:g,width:g.width,height:g.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:a}=this.props;return o?"".concat(e," ").concat(t," ").concat(i," ").concat(n," ").concat(s," ").concat(a):"".concat(e," ").concat(t," ").concat(i," ").concat(n)}}const J={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class q extends c.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[g.Z,d.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:e,oldProps:t,changeFlags:i}){if(super.updateState({props:e,oldProps:t,changeFlags:i}),i.extensionsChanged){var n;const{gl:e}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{viewport:t}=this.context,{billboard:i,sizeScale:n,sizeUnits:o,sizeMinPixels:s,sizeMaxPixels:a,getLineWidth:r}=this.props;let{padding:l}=this.props;const c="pixels"===o?t.metersPerPixel:1;l.length<4&&(l=[l[0],l[1],l[0],l[1]]),this.state.model.setUniforms(e).setUniforms({billboard:i,stroked:Boolean(r),padding:l,sizeScale:n*c,sizeMinPixels:s,sizeMaxPixels:a}).draw()}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new f.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}q.layerName="TextBackgroundLayer",q.defaultProps=J;const X={fontSize:64,buffer:4,sdf:!1,radius:12,cutoff:.25,smoothing:.1},Y={start:1,middle:0,end:-1},Q={top:1,center:0,bottom:-1},$=[0,0,0,255],ee=["fontSize","buffer","sdf","radius","cutoff"],te={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:$},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:j},fontFamily:U,fontWeight:N,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:$},fontSettings:{},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:$},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class ie extends a.Z{initializeState(){this.state={styleVersion:0,fontAtlasManager:new V}}updateState({props:e,oldProps:t,changeFlags:i}){const n=i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getText),o=this.state.characterSet;n&&this._updateText();const s=o!==this.state.characterSet||this._fontChanged(t,e);s&&this._updateFontAtlas(t,e),(s||e.lineHeight!==t.lineHeight||e.wordBreak!==t.wordBreak||e.maxWidth!==t.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(e,t){const{fontSettings:i,fontFamily:n,fontWeight:o}=t,{fontAtlasManager:s,characterSet:a}=this.state;s.setProps({...X,...i,characterSet:a,fontFamily:n,fontWeight:o})}_fontChanged(e,t){if(e.fontFamily!==t.fontFamily||e.fontWeight!==t.fontWeight)return!0;if(e.fontSettings===t.fontSettings)return!1;const i=e.fontSettings||{},n=t.fontSettings||{};return ee.some((e=>i[e]!==n[e]))}_updateText(){const{data:e,characterSet:t}=this.props,i=e.attributes&&e.attributes.getText;let n,{getText:o}=this.props,{startIndices:s}=e;const a="auto"===t&&new Set;if(i&&s){const{texts:t,characterCount:r}=function({value:e,length:t,stride:i,offset:n,startIndices:o,characterSet:s}){const a=e.BYTES_PER_ELEMENT,r=i?i/a:1,l=n?n/a:0,c=o[t]||Math.ceil((e.length-l)/r),g=s&&new Set,d=new Array(t);let u=e;if(r>1||l>0){u=new e.constructor(c);for(let t=0;t<c;t++)u[t]=e[t*r+l]}for(let e=0;e<t;e++){const t=o[e],i=o[e+1]||c,n=u.subarray(t,i);d[e]=String.fromCodePoint.apply(null,n),g&&n.forEach(g.add,g)}if(g)for(const e of g)s.add(String.fromCodePoint(e));return{texts:d,characterCount:c}}({...ArrayBuffer.isView(i)?{value:i}:i,length:e.length,startIndices:s,characterSet:a});n=r,o=(e,{index:i})=>t[i]}else{const{iterable:t,objectInfo:i}=(0,v.jB)(e);s=[0],n=0;for(const e of t){i.index++;const t=Array.from(o(e,i)||"");a&&t.forEach(a.add,a),n+=t.length,s.push(n)}}this.setState({getText:o,startIndices:s,numInstances:n,characterSet:a||t})}getBoundingRect(e,t){const i=this.state.fontAtlasManager.mapping,{getText:n}=this.state,{wordBreak:o,maxWidth:s,lineHeight:a,getTextAnchor:r,getAlignmentBaseline:l}=this.props,c=n(e,t)||"",{size:[g,d]}=D(c,a,o,s,i);return[(Y["function"==typeof r?r(e,t):r]-1)*g/2,(Q["function"==typeof l?l(e,t):l]-1)*d/2,g,d]}getIconOffsets(e,t){const i=this.state.fontAtlasManager.mapping,{getText:n}=this.state,{wordBreak:o,maxWidth:s,lineHeight:a,getTextAnchor:r,getAlignmentBaseline:l}=this.props,c=n(e,t)||"",{x:g,y:d,rowWidth:u,size:[f,h]}=D(c,a,o,s,i),p=Y["function"==typeof r?r(e,t):r],x=Q["function"==typeof l?l(e,t):l],y=g.length,m=new Array(2*y);let v=0;for(let e=0;e<y;e++){const t=(1-p)*(f-u[e])/2;m[v++]=(p-1)*f/2+t+g[e],m[v++]=(x-1)*h/2+d[e]}return m}renderLayers(){const{startIndices:e,numInstances:t,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:s},styleVersion:a}=this.state,{data:r,_dataDiff:l,getPosition:c,getColor:g,getSize:d,getAngle:u,getPixelOffset:f,getBackgroundColor:h,getBorderColor:p,getBorderWidth:x,backgroundPadding:y,background:m,billboard:v,fontSettings:_,outlineWidth:P,outlineColor:C,sizeScale:b,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:L,transitions:M,updateTriggers:O}=this.props,F=this.getSubLayerClass("characters",A),I=this.getSubLayerClass("background",q);return[m&&new I({getFillColor:h,getLineColor:p,getLineWidth:x,padding:y,getPosition:c,getSize:d,getAngle:u,getPixelOffset:f,billboard:v,sizeScale:b/this.state.fontAtlasManager.props.fontSize,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:L,transitions:M&&{getPosition:M.getPosition,getAngle:M.getAngle,getSize:M.getSize,getFillColor:M.getBackgroundColor,getLineColor:M.getBorderColor,getLineWidth:M.getBorderWidth,getPixelOffset:M.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:O.getPosition,getAngle:O.getAngle,getSize:O.getSize,getFillColor:O.getBackgroundColor,getLineColor:O.getBorderColor,getLineWidth:O.getBorderWidth,getPixelOffset:O.getPixelOffset,getBoundingRect:{getText:O.getText,getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:r.attributes?{length:r.length,attributes:r.attributes.background||{}}:r,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect.bind(this)}),new F({sdf:_.sdf,smoothing:Number.isFinite(_.smoothing)?_.smoothing:X.smoothing,outlineWidth:P,outlineColor:C,iconAtlas:o,iconMapping:s,getPosition:c,getColor:g,getSize:d,getAngle:u,getPixelOffset:f,billboard:v,sizeScale:b*n,sizeUnits:S,sizeMinPixels:z*n,sizeMaxPixels:L*n,transitions:M&&{getPosition:M.getPosition,getAngle:M.getAngle,getColor:M.getColor,getSize:M.getSize,getPixelOffset:M.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getIcon:O.getText,getPosition:O.getPosition,getAngle:O.getAngle,getColor:O.getColor,getSize:O.getSize,getPixelOffset:O.getPixelOffset,getIconOffsets:{getText:O.getText,getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:r,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets.bind(this),getIcon:i})]}}ie.layerName="TextLayer",ie.defaultProps=te;var ne=i(62112),oe=i(71435);const se={circle:{type:F.Z,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:O,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:ie,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},ae={type:ne.Z,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",getLineColor:"getColor",getLineWidth:"getWidth"}},re={type:oe.Z,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function le({type:e,props:t}){const i={};for(const n in t)i[n]=e.defaultProps[t[n]];return i}function ce(e,t){const{transitions:i,updateTriggers:n}=e.props,o={updateTriggers:{},transitions:i&&{getPosition:i.geometry}};for(const s in t){const a=t[s];let r=e.props[s];s.startsWith("get")&&(r=e.getSubLayerAccessor(r),o.updateTriggers[a]=n[s],i&&(o.transitions[a]=i[s])),o[a]=r}return o}function ge(e,t,i={}){const n={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=e.length}=i;for(let i=o;i<s;i++){const o=e[i];r.Z.assert(o&&o.geometry,"GeoJSON does not have geometry");const{geometry:s}=o;if("GeometryCollection"===s.type){r.Z.assert(Array.isArray(s.geometries),"GeoJSON does not have geometries array");const{geometries:e}=s;for(let s=0;s<e.length;s++)de(e[s],n,t,o,i)}else de(s,n,t,o,i)}return n}function de(e,t,i,n,o){const{type:s,coordinates:a}=e,{pointFeatures:l,lineFeatures:c,polygonFeatures:g,polygonOutlineFeatures:d}=t;if(function(e,t){let i=ue[e];for(r.Z.assert(i,"Unknown GeoJSON type ".concat(e));t&&--i>0;)t=t[0];return t&&Number.isFinite(t[0])}(s,a))switch(s){case"Point":l.push(i({geometry:e},n,o));break;case"MultiPoint":a.forEach((e=>{l.push(i({geometry:{type:"Point",coordinates:e}},n,o))}));break;case"LineString":c.push(i({geometry:e},n,o));break;case"MultiLineString":a.forEach((e=>{c.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}));break;case"Polygon":g.push(i({geometry:e},n,o)),a.forEach((e=>{d.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}));break;case"MultiPolygon":a.forEach((e=>{g.push(i({geometry:{type:"Polygon",coordinates:e}},n,o)),e.forEach((e=>{d.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}))}))}else r.Z.warn("".concat(s," coordinates are malformed"))()}const ue={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function fe(e){return e.geometry.coordinates}const he={...le(se.circle),...le(se.icon),...le(se.text),...le(ae),...le(re),stroked:!0,filled:!0,extruded:!1,wireframe:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:e=>e.properties.icon},getText:{type:"accessor",value:e=>e.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class pe extends a.Z{initializeState(){this.state={layerProps:{},features:{}},this.props.getLineDashArray&&r.Z.removed("getLineDashArray","PathStyleExtension")()}updateState({props:e,changeFlags:t}){if(!t.dataChanged)return;const{data:i}=this.props,n=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:n}),n?this._updateStateBinary({props:e,changeFlags:t}):this._updateStateJSON({props:e,changeFlags:t})}_updateStateBinary({props:e,changeFlags:t}){const i=function(e,t){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:n,lines:o,polygons:s}=e,a=function(e,t){const i={points:null,lines:null,polygons:null};for(const n in i){const o=e[n].globalFeatureIds.value;i[n]=new Uint8ClampedArray(3*o.length);const s=[];for(let e=0;e<o.length;e++)t(o[e],s),i[n][3*e+0]=s[0],i[n][3*e+1]=s[1],i[n][3*e+2]=s[2]}return i}(e,t);return i.points.data={length:n.positions.value.length/n.positions.size,attributes:{getPosition:n.positions,instancePickingColors:{size:3,value:a.points}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},i.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{getPath:o.positions,instancePickingColors:{size:3,value:a.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},i.lines._pathType="open",i.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{getPolygon:s.positions,pickingColors:{size:3,value:a.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygons._normalize=!1,s.triangles&&(i.polygons.data.attributes.indices=s.triangles.value),i.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{getPath:s.positions,instancePickingColors:{size:3,value:a.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygonsOutline._pathType="open",i}(e.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON({props:e,changeFlags:t}){const i=function(e){if(Array.isArray(e))return e;switch(r.Z.assert(e.type,"GeoJSON does not have type"),e.type){case"Feature":return[e];case"FeatureCollection":return r.Z.assert(Array.isArray(e.features),"GeoJSON does not have features array"),e.features;default:return[{geometry:e}]}}(e.data),n=this.getSubLayerRow.bind(this);let o={};const s={};if(Array.isArray(t.dataChanged)){const e=this.state.features;for(const t in e)o[t]=e[t].slice(),s[t]=[];for(const a of t.dataChanged){const t=ge(i,n,a);for(const i in e)s[i].push((0,l.b)({data:o[i],getIndex:e=>e.__source.index,dataRange:a,replace:t[i]}))}}else o=ge(i,n);const a=function(e,t){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:n,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:a}=e;return i.points.data=n,i.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),i.points.getPosition=fe,i.lines.data=o,i.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),i.lines.getPath=fe,i.polygons.data=s,i.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),i.polygons.getPolygon=fe,i.polygonsOutline.data=a,i.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),i.polygonsOutline.getPath=fe,i}(o,s);this.setState({features:o,featuresDiff:s,layerProps:a})}_updateAutoHighlight(e){const t="".concat(this.id,"-points-"),i=e.sourceLayer.id.startsWith(t);for(const n of this.getSubLayers())n.id.startsWith(t)===i&&n.updateAutoHighlight(e)}_renderPolygonLayer(){const{extruded:e,wireframe:t}=this.props,{layerProps:i}=this.state,n="polygons-fill",o=this.shouldRenderSubLayer(n,i.polygons.data)&&this.getSubLayerClass(n,re.type);if(o){const s=ce(this,re.props),a=e&&t;return a||delete s.getLineColor,s.updateTriggers.lineColors=a,new o(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){const{extruded:e,stroked:t}=this.props,{layerProps:i}=this.state,n="polygons-stroke",o="linestrings",s=!e&&t&&this.shouldRenderSubLayer(n,i.polygonsOutline.data)&&this.getSubLayerClass(n,ae.type),a=this.shouldRenderSubLayer(o,i.lines.data)&&this.getSubLayerClass(o,ae.type);if(s||a){const e=ce(this,ae.props);return[s&&new s(e,this.getSubLayerProps({id:n,updateTriggers:e.updateTriggers}),i.polygonsOutline),a&&new a(e,this.getSubLayerProps({id:o,updateTriggers:e.updateTriggers}),i.lines)]}return null}_renderPointLayers(){const{pointType:e}=this.props,{layerProps:t,binary:i}=this.state;let{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=t.points.data.findIndex((e=>e.__source.index===n)));const o=new Set(e.split("+")),s=[];for(const e of o){const i="points-".concat(e),o=se[e],a=o&&this.shouldRenderSubLayer(i,t.points.data)&&this.getSubLayerClass(i,o.type);if(a){const e=ce(this,o.props);s.push(new a(e,this.getSubLayerProps({id:i,updateTriggers:e.updateTriggers,highlightedObjectIndex:n}),t.points))}}return s}renderLayers(){const{extruded:e}=this.props,t=this._renderPolygonLayer();return[!e&&t,this._renderLineLayers(),this._renderPointLayers(),e&&t]}getSubLayerAccessor(e){const{binary:t}=this.state;return t&&"function"==typeof e?(t,i)=>{const{data:n,index:o}=i,s=function(e,t){if(!e)return null;const i="startIndices"in e?e.startIndices[t]:t,n=e.featureIds.value[i];return-1!==i?function(e,t,i){const n={properties:{...e.properties[t]}};for(const t in e.numericProps)n.properties[t]=e.numericProps[t].value[i];return n}(e,n,i):null}(n,o);return e(s,i)}:super.getSubLayerAccessor(e)}}pe.layerName="GeoJsonLayer",pe.defaultProps=he;var xe=i(85011),ye=i(15191),me=i(88574),ve=i(37032),_e=i(57981);function Pe(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function Ce(){return Ce=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e},Ce.apply(this,arguments)}const be={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},Se=(e,t)=>{const i={};return Object.keys(e).forEach((t=>{t in be?i[be[t]]=e[t]:i[t]=e[t]})),"string"==typeof e.fillColor&&(i.fillColor=(0,ye.hexToRGB)(e.fillColor)),"string"==typeof e.strokeColor&&(i.strokeColor=(0,ye.hexToRGB)(e.strokeColor)),Ce({},i,{},t)};let ze;const Le=(e,t,i)=>{if(e&&e.features&&e.features.forEach((n=>{Le(n,t,e.extraProps||i)})),e&&e.geometry){const n=Ce({},e,{properties:Se(e.properties,t)});n.extraProps||(n.extraProps=i),ze.push(n)}};function Me(e){return e.object.extraProps&&n.createElement("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,i)=>n.createElement(_e.Z,{key:"prop-"+i,label:t+": ",value:""+e.object.extraProps[t]}))))}function Oe(e,t,i,n){const o=e,s=o.fill_color_picker,a=o.stroke_color_picker,r=[s.r,s.g,s.b,255*s.a],l=[a.r,a.g,a.b,255*a.a],c={};let g;return r[3]>0&&(c.fillColor=r),l[3]>0&&(c.strokeColor=l),ze=[],Le(t.data,c),o.js_data_mutator&&(g=(0,me.Z)(o.js_data_mutator),ze=g(ze)),new pe(Ce({id:"geojson-layer-"+o.slice_id,filled:o.filled,data:ze,stroked:o.stroked,extruded:o.extruded,pointRadiusScale:o.point_radius_scale},(0,ve.N)(o,n,Me)))}const Fe={formData:s().object.isRequired,payload:s().object.isRequired,setControlValue:s().func.isRequired,viewport:s().object.isRequired,onAddFilter:s().func},Ie={onAddFilter(){}};class Ae extends n.Component{constructor(){super(...arguments),Pe(this,"containerRef",n.createRef()),Pe(this,"setTooltip",(e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)}))}render(){const{formData:e,payload:t,setControlValue:i,onAddFilter:o,viewport:s}=this.props,a=Oe(e,t,0,this.setTooltip);return n.createElement(xe.Z,{ref:this.containerRef,mapboxApiAccessToken:t.data.mapboxApiKey,viewport:s,layers:[a],mapStyle:e.mapbox_style,setControlValue:i})}}Ae.propTypes=Fe,Ae.defaultProps=Ie;const we=Ae}}]);