(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3776,7893],{46811:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>R});var o=n(67294),r=n(96486),a=n.n(r),i=n(45697),s=n.n(i),c=n(21173),l=n(85011),u=n(54998),g=n.n(u);function d(e,t,n,o){if(void 0===n&&(n=!0),void 0===o&&(o={}),!e.datasource)return null;const r=new(g())("/"),a=function(e,t){void 0===t&&(t="base");let n="/superset/explore/";return["json","csv","query","results","samples"].includes(t)&&(n="/superset/explore_json/"),n}(0,t),i=r.search(!0);Object.keys(o).forEach((e=>{i[e]=o[e]})),i.form_data=function(e){const t=new Set;return JSON.stringify(e,((e,n)=>{if("object"==typeof n&&null!==n){if(t.has(n))try{return JSON.parse(JSON.stringify(n))}catch(e){return}t.add(n)}return n}))}(e),"standalone"===t&&(i.standalone="true");const s=r.directory(a).search(i).toString();return!n&&s.length>8e3?d({datasource:e.datasource,viz_type:e.viz_type},t,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var p=n(54486),h=n(28230),f=n(97492),v=n(1186),m=n(4598),x=n(24022),_=n(66585),y=n(83265);const P={deck_grid:p.getLayer,deck_screengrid:h.getLayer,deck_path:f.getLayer,deck_hex:v.getLayer,deck_scatter:m.getLayer,deck_geojson:x.getLayer,deck_arc:_.getLayer,deck_polygon:y.getLayer};function b(){return b=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},b.apply(this,arguments)}function S(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const w={formData:s().object.isRequired,payload:s().object.isRequired,setControlValue:s().func.isRequired,viewport:s().object.isRequired,onAddFilter:s().func,onSelect:s().func},C={onAddFilter(){},onSelect(){}};class L extends o.PureComponent{constructor(e){super(e),S(this,"containerRef",o.createRef()),S(this,"setTooltip",(e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)})),this.state={subSlicesLayers:{}},this.onViewportChange=this.onViewportChange.bind(this)}componentDidMount(){const{formData:e,payload:t}=this.props;this.loadLayers(e,t)}UNSAFE_componentWillReceiveProps(e){const{formData:t,payload:n}=e;!a().isEqual(this.props.formData.deck_slices,e.formData.deck_slices)&&this.loadLayers(t,n)}onViewportChange(e){this.setState({viewport:e})}loadLayers(e,t,n){this.setState({subSlicesLayers:{},viewport:n}),t.data.slices.forEach((t=>{const n=[...t.form_data.filters||[],...e.filters||[],...e.extra_filters||[]],o=b({},t,{form_data:b({},t.form_data,{filters:n})});c.Z.get({endpoint:d(o.form_data,"json")}).then((e=>{let{json:t}=e;const n=P[o.form_data.viz_type](o.form_data,t,this.props.onAddFilter,this.setTooltip,[],this.props.onSelect);this.setState({subSlicesLayers:b({},this.state.subSlicesLayers,{[o.slice_id]:n})})})).catch((()=>{}))}))}render(){const{payload:e,formData:t,setControlValue:n}=this.props,{subSlicesLayers:r}=this.state,a=Object.values(r);return o.createElement(l.Z,{ref:this.containerRef,mapboxApiAccessToken:e.data.mapboxApiKey,viewport:this.state.viewport||this.props.viewport,layers:a,mapStyle:t.mapbox_style,setControlValue:n,onViewportChange:this.onViewportChange})}}L.propTypes=w,L.defaultProps=C;const R=L},66585:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>x,getLayer:()=>m});var o=n(95772),r=n(93844),a=n(51331),i=n(281),s=n(53982);const c=[0,0,0,255],l={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:c},getTargetColor:{type:"accessor",value:c},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class u extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.Z,a.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:c},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:c},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState({props:e,oldProps:t,changeFlags:n}){if(super.updateState({props:e,oldProps:t,changeFlags:n}),n.extensionsChanged){var o;const{gl:e}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{viewport:t}=this.context,{widthUnits:n,widthScale:o,widthMinPixels:r,widthMaxPixels:a,greatCircle:i,wrapLongitude:s}=this.props,c="pixels"===n?t.metersPerPixel:1;this.state.model.setUniforms(e).setUniforms({greatCircle:i,widthScale:o*c,widthMinPixels:r,widthMaxPixels:a,useShortestPath:s}).draw()}_getModel(e){let t=[];for(let e=0;e<50;e++)t=t.concat([e,1,0,e,-1,0]);const n=new i.Z(e,{...this.getShaders(),id:this.props.id,geometry:new s.Z({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0});return n.setUniforms({numSegments:50}),n}}u.layerName="ArcLayer",u.defaultProps=l;var g=n(67294),d=n(60650),p=n(37032),h=n(52598),f=n(57981);function v(){return v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},v.apply(this,arguments)}function m(e,t,n,o){const r=t.data.features,a=e.color_picker,i=e.target_color_picker;return new u(v({data:r,getSourceColor:e=>e.sourceColor||e.color||[a.r,a.g,a.b,255*a.a],getTargetColor:e=>e.targetColor||e.color||[i.r,i.g,i.b,255*i.a],id:"path-layer-"+e.slice_id,strokeWidth:e.stroke_width?e.stroke_width:3},(0,p.N)(e,o,(s=e,e=>g.createElement("div",{className:"deckgl-tooltip"},g.createElement(f.Z,{label:(0,d.t)("Start (Longitude, Latitude)")+": ",value:e.object.sourcePosition[0]+", "+e.object.sourcePosition[1]}),g.createElement(f.Z,{label:(0,d.t)("End (Longitude, Latitude)")+": ",value:e.object.targetPosition[0]+", "+e.object.targetPosition[1]}),s.dimension&&g.createElement(f.Z,{label:s.dimension+": ",value:""+e.object.cat_color}))))));var s}const x=(0,h.B)(m,(function(e){const t=[];return e.forEach((e=>{t.push(e.sourcePosition),t.push(e.targetPosition)})),t}))},1186:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>C,getLayer:()=>w});var o=n(80744),r=n(15103),a=n(4516),i=Math.PI/3,s=[0,i,2*i,3*i,4*i,5*i];function c(e){return e[0]}function l(e){return e[1]}var u=n(38550),g=n(73728),d=n(63295);function p(){}const h={colorDomain:null,colorRange:a.K,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:p,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:p,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(e,t){const{data:n,radius:r}=e,{viewport:a,attributes:g}=t,d=n.length?function(e,t){const{attributes:n}=t,o=n.positions.value,{size:r}=n.positions.getAccessor();let a,i=1/0,s=1/0,c=-1/0,l=-1/0;for(a=0;a<r*e.length;a+=r){const e=o[a],t=o[a+1];Number.isFinite(e)&&Number.isFinite(t)&&(i=Math.min(e,i),c=Math.max(e,c),s=Math.min(t,s),l=Math.max(t,l))}return[i,s,c,l].every(Number.isFinite)?[(i+c)/2,(s+l)/2]:null}(n,t):null,p=function(e,t,n){const{unitsPerMeter:o}=t.getDistanceScales(n);return e*o[0]}(r,a,d),h=[],{iterable:f,objectInfo:v}=(0,u.jB)(n),m=g.positions.value,{size:x}=g.positions.getAccessor();for(const e of f){v.index++;const t=v.index*x,n=[m[t],m[t+1]];Number.isFinite(n[0])&&Number.isFinite(n[1])?h.push({screenCoord:a.projectFlat(n),source:e,index:v.index}):o.Z.warn("HexagonLayer: invalid position")()}const _=function(){var e,t,n,o=0,r=0,a=1,u=1,g=c,d=l;function p(e){var o,r={},a=[],i=e.length;for(o=0;o<i;++o)if(!isNaN(c=+g.call(null,s=e[o],o,e))&&!isNaN(l=+d.call(null,s,o,e))){var s,c,l,u=Math.round(l/=n),p=Math.round(c=c/t-(1&u)/2),h=l-u;if(3*Math.abs(h)>1){var f=c-p,v=p+(c<p?-1:1)/2,m=u+(l<u?-1:1),x=c-v,_=l-m;f*f+h*h>x*x+_*_&&(p=v+(1&u?1:-1)/2,u=m)}var y=p+"-"+u,P=r[y];P?P.push(s):(a.push(P=r[y]=[s]),P.x=(p+(1&u)/2)*t,P.y=u*n)}return a}function h(e){var t=0,n=0;return s.map((function(o){var r=Math.sin(o)*e,a=-Math.cos(o)*e,i=r-t,s=a-n;return t=r,n=a,[i,s]}))}return p.hexagon=function(t){return"m"+h(null==t?e:+t).join("l")+"z"},p.centers=function(){for(var i=[],s=Math.round(r/n),c=Math.round(o/t),l=s*n;l<u+e;l+=n,++s)for(var g=c*t+(1&s)*t/2;g<a+t/2;g+=t)i.push([g,l]);return i},p.mesh=function(){var t=h(e).slice(0,4).join("l");return p.centers().map((function(e){return"M"+e+"m"+t})).join("")},p.x=function(e){return arguments.length?(g=e,p):g},p.y=function(e){return arguments.length?(d=e,p):d},p.radius=function(o){return arguments.length?(t=2*(e=+o)*Math.sin(i),n=1.5*e,p):e},p.size=function(e){return arguments.length?(o=r=0,a=+e[0],u=+e[1],p):[a-o,u-r]},p.extent=function(e){return arguments.length?(o=+e[0][0],r=+e[0][1],a=+e[1][0],u=+e[1][1],p):[[o,r],[a,u]]},p.radius(1)}().radius(p).x((e=>e.screenCoord[0])).y((e=>e.screenCoord[1]));return{hexagons:_(h).map(((e,t)=>({position:a.unprojectFlat([e.x,e.y]),points:e,index:t}))),radiusCommon:p}},getPosition:{type:"accessor",value:e=>e.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class f extends d.Z{shouldUpdateState({changeFlags:e}){return e.somethingChanged}initializeState(){const e=new g.Z({getAggregator:e=>e.hexagonAggregator,getCellSize:e=>e.radius});this.state={cpuAggregator:e,aggregatorState:e.state,hexagonVertices:null},this.getAttributeManager().add({positions:{size:3,accessor:"getPosition"}})}updateState(e){super.updateState(e);const{cpuAggregator:t,hexagonVertices:n}=this.state;e.changeFlags.propsOrDataChanged&&this.setState({aggregatorState:t.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()})});const{hexagonVertices:o}=t.state.layerData||{};if(o&&n!==o){const e=this.convertLatLngToMeterOffset(o);e&&this.setState({hexagonVertices:o,vertices:e})}else this.updateRadiusAngle()}updateRadiusAngle(e){const{viewport:t}=this.context,{unitsPerMeter:n}=t.getDistanceScales(),{cpuAggregator:o}=this.state;if(o.state.layerData&&o.state.layerData.radiusCommon){const{radiusCommon:e}=o.state.layerData,t=e/n[0];this.setState({angle:90,radius:t})}}convertLatLngToMeterOffset(e){const{viewport:t}=this.context;if(Array.isArray(e)&&6===e.length){const n=e[0],o=e[3],r=[(n[0]+o[0])/2,(n[1]+o[1])/2],a=t.projectFlat(r),{metersPerUnit:i}=t.getDistanceScales(r);return e.map((e=>{const n=t.projectFlat(e);return[(n[0]-a[0])*i[0],(n[1]-a[1])*i[1]]}))}return o.Z.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,coverage:n,material:o,transitions:a}=this.props,{angle:i,radius:s,cpuAggregator:c,vertices:l}=this.state,u=this.getSubLayerClass("hexagon-cell",r.Z),g=this._getSublayerUpdateTriggers();return new u({...l&&l.length?{vertices:l,radius:1}:{radius:s,angle:i},diskResolution:6,elevationScale:e,extruded:t,coverage:n,material:o,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getFillColor:a.getColorValue||a.getColorWeight,getElevation:a.getElevationValue||a.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:g}),{data:c.state.layerData.data})}}f.layerName="HexagonLayer",f.defaultProps=h;var v=n(67294),m=n(60650),x=n(37032),_=n(88574),y=n(52598),P=n(57981);function b(){return b=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},b.apply(this,arguments)}function S(e){return v.createElement("div",{className:"deckgl-tooltip"},v.createElement(P.Z,{label:(0,m.t)("Centroid (Longitude and Latitude)")+": ",value:"("+e.coordinate[0]+", "+e.coordinate[1]+")"}),v.createElement(P.Z,{label:(0,m.t)("Height")+": ",value:""+e.object.elevationValue}))}function w(e,t,n,o){const r=e,a=r.color_picker;let i=t.data.features.map((e=>b({},e,{color:[a.r,a.g,a.b,255*a.a]})));r.js_data_mutator&&(i=(0,_.Z)(r.js_data_mutator)(i));const s=(0,x.Z)(r.js_agg_function,(e=>e.weight));return new f(b({id:"hex-layer-"+r.slice_id,data:i,pickable:!0,radius:r.grid_size,minColor:[0,0,0,0],extruded:r.extruded,maxColor:[a.r,a.g,a.b,255*a.a],outline:!1,getElevationValue:s,getColorValue:s},(0,x.N)(r,o,S)))}const C=(0,y.G)(w,(function(e){return e.map((e=>e.position))}))},97492:(e,t,n)=>{"use strict";n.r(t),n.d(t,{getLayer:()=>g,default:()=>d});var o=n(62112),r=n(67294),a=n(37032),i=n(88574),s=n(52598),c=n(57981);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},l.apply(this,arguments)}function u(e){return e.object.extraProps&&r.createElement("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,n)=>r.createElement(c.Z,{key:"prop-"+n,label:t+": ",value:""+e.object.extraProps[t]}))))}function g(e,t,n,r){const s=e,c=s.color_picker,g=[c.r,c.g,c.b,255*c.a];let d=t.data.features.map((e=>l({},e,{path:e.path,width:s.line_width,color:g})));return s.js_data_mutator&&(d=(0,i.Z)(s.js_data_mutator)(d)),new o.Z(l({id:"path-layer-"+s.slice_id,getColor:e=>e.color,getPath:e=>e.path,getWidth:e=>e.width,data:d,rounded:!0,widthScale:1},(0,a.N)(s,r,u)))}const d=(0,s.G)(g,(function(e){let t=[];return e.forEach((e=>{t=t.concat(e.path)})),t}))},4598:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>p,getLayer:()=>d});var o=n(28569),r=n(67294),a=n(95669),i=n(60650),s=n(37032),c=n(52598),l=n(57981);const u=1609.34;function g(){return g=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},g.apply(this,arguments)}function d(e,t,n,c,d){const p=e,h=t.data.features.map((e=>{let t=(n=p.point_unit,o=e.radius,("square_m"===n?Math.sqrt(o/Math.PI):"radius_m"===n?o:"radius_km"===n?1e3*o:"radius_miles"===n?o*u:"square_km"===n?1e3*Math.sqrt(o/Math.PI):"square_miles"===n?Math.sqrt(o/Math.PI)*u:null)||10);var n,o;if(p.multiplier&&(t*=p.multiplier),e.color)return g({},e,{radius:t});const r=p.color_picker||{r:0,g:0,b:0,a:1};return g({},e,{radius:t,color:[r.r,r.g,r.b,255*r.a]})}));return new o.Z(g({id:"scatter-layer-"+p.slice_id,data:h,fp64:!0,getFillColor:e=>e.color,getRadius:e=>e.radius,radiusMinPixels:p.min_radius||null,radiusMaxPixels:p.max_radius||null,stroked:!1},(0,s.N)(p,c,function(e,t){return n=>{var o;const s=(null==t?void 0:t[e.point_radius_fixed.value])||(0,a.Z)(null==(o=e.point_radius_fixed)?void 0:o.value);return r.createElement("div",{className:"deckgl-tooltip"},r.createElement(l.Z,{label:(0,i.t)("Longitude and Latitude")+": ",value:n.object.position[0]+", "+n.object.position[1]}),n.object.cat_color&&r.createElement(l.Z,{label:(0,i.t)("Category")+": ",value:""+n.object.cat_color}),n.object.metric&&r.createElement(l.Z,{label:s+": ",value:""+n.object.metric}))}}(p,null==d?void 0:d.verboseMap))))}const p=(0,c.B)(d,(function(e){return e.map((e=>e.position))}))},92540:()=>{},95751:()=>{},75307:()=>{}}]);